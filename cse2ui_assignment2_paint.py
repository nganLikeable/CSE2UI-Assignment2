# -*- coding: utf-8 -*-
"""CSE2UI_Assignment2_Paint.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J15stHO6m03zfpI3UxSoVd2fxj5iGrrq
"""

import tkinter as tk
from tkinter import ttk
from tkinter import colorchooser, filedialog, messagebox, Menu, DOTBOX
from PIL import ImageGrab, Image, ImageTk



class Application(tk.Frame):
    def __init__(self, window_width, window_height, root=None):
        super().__init__(root)
        self.root = root

        self.style = ttk.Style()
        self.style.theme_use('clam')  # Set the theme for buttons, those with ttk.Button

        # Default mode
        self.brush_color = 'black'
        self.background_color = 'white'
        self.brush_size = 5
        self.eraser_on = False
        self.shape_tool = 'pen'  # Track the current tool (pen or shape)

        # Placeholders objects
        self.start_x, self.start_y = None, None
        self.current_shape = None
        self.text_box = None
        self.drag_data = None
        self.canvas_textbox = None
        self.current_circle = None

        self.canvas_data = [] #Store canvas details




        # Create frame for canvas and controls
        self.frame = tk.Frame(self.root, width=window_width, height=window_height)
        self.frame.grid(row=0, column=0, padx=0, pady=0)

        # Create canvas
        self.canvas = tk.Canvas(self.frame, bg=self.background_color, width=1000, height=500)
        self.canvas.grid(row=0, column=1, rowspan=5, padx=0, pady=0)
        self.canvas.config(cursor="pencil")
        self.circle_canvas = tk.Canvas(self.frame, background=root["bg"], width=200, height=200)
        self.circle_canvas.place(x=120, y=515, width=150, height=90)


        # Binding left mouse click to drawing function
        self.canvas.bind('<B1-Motion>', self.paint)
        self.canvas.bind('<Button-1>', self.start_draw)
        self.canvas.bind('<ButtonRelease-1>', self.reset)



        # Add default colors
        colors = ['white', 'gray', 'black', 'brown', 'red', 'orange', 'yellow', 'lime',
                  'dark green', 'navy', 'purple', 'light blue', 'pink']

        color_frame = tk.Frame(self.frame)
        color_frame.grid(row=5, column=1, pady=0)

        for i, color in enumerate(colors):
            self.color_button = tk.Button(color_frame, bg=color, width=2, height=1, command=lambda c=color: self.set_color(c))
            self.color_button.grid(row=0, column=i, padx=5)

        # Pen button
        self.pen_button = ttk.Button(self.frame, text="Pen", command=self.use_pen)
        self.pen_button.grid(row=0, column=0, padx=0, pady=0)

        # Color selection button for custom color
        self.color_button = ttk.Button(self.frame, text="Brush Color", command=self.change_brush_color)
        self.color_button.grid(row=1, column=0, padx=0, pady=0)

        # Change background color button
        self.background_color_button = ttk.Button(self.frame, text='Background Color', command=self.change_background)
        self.background_color_button.grid(row=2, column=0, padx=0, pady=0)

        # Eraser button
        self.eraser_button = ttk.Button(self.frame, text="Eraser", command=self.use_eraser)
        self.eraser_button.grid(row=3, column=0, padx=0, pady=0)

        # Clear canvas button
        self.clear_button = ttk.Button(self.frame, text="Clear", command=self.clear_canvas)
        self.clear_button.grid(row=4, column=0, padx=0, pady=0)

        # Brush size slider
        self.size_slider = tk.Scale(self.frame, from_=1, to=50, orient='horizontal', label='Size', command=self.update_circle_size)
        self.size_slider.set(self.brush_size)  # Default brush size
        self.size_slider.grid(row=5, column=0, padx=10, pady=10)

        # Shape menu at the last option
        self.shape_menu = ttk.Menubutton(self.frame, text="Shapes")
        self.shape_menu.menu = Menu(self.shape_menu, tearoff=0)
        self.shape_menu['menu'] = self.shape_menu.menu
        for shape in ["Rectangle", "Oval", "Line"]:
            self.shape_menu.menu.add_command(label=shape, command=lambda s=shape.lower(): self.set_tool(s))
        self.shape_menu.grid(row=6, column=0, padx=0, pady=10)  # Moved shape menu to the last position

        #save button
        self.save_button = ttk.Button(self.frame, text="SAVE", command = self.save_canvas )
        self.save_button.place(x=530, y=570, width=100, height=30)

        #open button
        self.open_button = ttk.Button(self.frame, text="OPEN", command = self.open_canvas )
        self.open_button.place(x=630, y=570, width=100, height=30)


        # Write Text button
        self.text_button = ttk.Button(self.frame, text="Textbox", command=self.text_button_clicked)
        self.text_button.place(x=150, y=597, width=100, height=30)




    def set_color(self, color):
        """Set the brush color from the default color options."""
        if not self.eraser_on:  # Only change the color if eraser is NOT active
            self.brush_color = color

    def change_brush_color(self):
        """Opens a color chooser dialog to select a custom pen color."""
        if not self.eraser_on:  # Only allow changing color if eraser is not active
            color = colorchooser.askcolor(color=self.brush_color)[1]
            if color:
                self.brush_color = color

    def change_background(self):
        """Change the background color and update the canvas."""
        self.background_color = colorchooser.askcolor(color=self.background_color)[1]
        if self.background_color: # If chosen a color, set canvas color
            self.canvas.config(bg=self.background_color)
        self.eraser_on = False

    def set_tool(self, tool):
        """Set the drawing tool (pen or shape)."""
        self.shape_tool = tool

    def use_pen(self):
        """Switch to pen mode."""
        self.eraser_on = False # Disable eraser
        self.shape_tool = 'pen'  # Set tool to pen
        if hasattr(self, 'previous_brush_color'):

            self.brush_color = self.previous_brush_color  # Restore the previous brush color if it was set

        self.canvas.config(cursor="pencil")

    def paint(self, event):
        """Draw on the canvas with continuous lines or shapes."""
        if self.shape_tool == 'pen':
            self.draw_pen(event)
        elif self.shape_tool in ['rectangle', 'oval', 'line']:
            self.draw_shape(event)

    def draw_pen(self, event):
        """Sets brush size and draw continous line with pen."""
        self.brush_size = self.size_slider.get()

        color = self.brush_color

        # If there's a previous position, draw a line from the previous position to the current one
        if self.start_x is not None and self.start_y is not None:
            self.canvas.create_line(self.start_x, self.start_y, event.x, event.y,
                                    fill=color, width=self.brush_size, capstyle=tk.ROUND, smooth=True)

        # Update the last known position to the current one
        self.start_x, self.start_y = event.x, event.y


    def create_circle(self):
        """Create a preview circle based on the current brush size."""
        diameter = self.size_slider.get()
        radius = diameter / 2

        if self.current_circle:
            self.circle_canvas.delete(self.current_circle)  # Remove the previous circle if it exists

        # Calculate the center the preview oval in circle_canvas
        circlecanvas_width = self.circle_canvas.winfo_width()
        circlecanvas_height = self.circle_canvas.winfo_height()
        x = circlecanvas_width / 2
        y = circlecanvas_height / 2

        # Draw a circle (oval) using the current brush size as diameter
        self.current_circle = self.circle_canvas.create_oval(x - radius, y - radius, x + radius, y + radius,
                                                             fill="black")

    def update_circle_size(self, event):
        """Update the circle size when the brush size slider is adjusted."""
        self.create_circle()  # Update the circle


    def use_eraser(self):
        """Switch to eraser mode temporarily."""
        self.eraser_on = True
        self.shape_tool = 'pen'  # Set tool to pen

        self.previous_brush_color = self.brush_color  # Temporarily store the current brush color
        self.brush_color = self.background_color  # Set brush color to background for erasing

        self.canvas.config(cursor="DOTBOX")

    def start_draw(self, event):
        """Initialize drawing."""
        self.start_x = event.x
        self.start_y = event.y
        self.current_shape = None  # Reset current shape for new shape

    def draw_shape(self, event):
        """Draw the selected shape on the canvas."""
        if self.current_shape:  # If there's an item being drawn, we need to update its size
            self.canvas.delete(self.current_shape)

        if self.shape_tool == 'rectangle':
            self.current_shape = self.canvas.create_rectangle(self.start_x, self.start_y, event.x, event.y,
                                                             outline=self.brush_color, width=self.brush_size)
        elif self.shape_tool == 'oval':
            self.current_shape = self.canvas.create_oval(self.start_x, self.start_y, event.x, event.y,
                                                         outline=self.brush_color, width=self.brush_size)
        elif self.shape_tool == 'line':
            self.current_shape = self.canvas.create_line(self.start_x, self.start_y, event.x, event.y,
                                                         fill=self.brush_color, width=self.brush_size)


    def reset(self, event=None):
        """Reset the last mouse position when the button is released."""
        self.start_x, self.start_y = None, None

    def clear_canvas(self):
        """Clears the entire canvas."""
        self.canvas.delete('all')

    #Textbox todolist:
    # make it deletable, resizable, movable
    def text_button_clicked(self):
        self.canvas.bind('<Button-1>', self.create_textbox)

    def create_textbox(self, event):
        """Create a text box on the canvas."""
        self.text_box = tk.Text(self.canvas, height=3, width=20, wrap="word", bg="white")
        self.canvas_textbox = self.canvas.create_window(event.x, event.y, window=self.text_box)
        self.text_box.bind("<Button-1>", self.start_drag)
        self.text_box.bind("<B1-Motion>", self.perform_drag)


        self.canvas.bind('<Button-1>', self.start_draw) # Unbind, set default bind for other functions to work
    def start_drag(self, event):
        """Start dragging the text box."""
        self.drag_data = (event.x, event.y)

    def perform_drag(self, event):
        """Drag the text box based on the starting point."""
        if self.drag_data:
            dx = event.x - self.drag_data[0]
            dy = event.y - self.drag_data[1]
            self.canvas.move(self.canvas_textbox, dx, dy)



    #save canvas
    def save_canvas(self):
            # Open file dialog to save the image
        file_saved = filedialog.asksaveasfilename(defaultextension=".jpg",
                                                  filetypes=[("JPEG files", "*.jpg"),
                                                             ("PNG files", "*.png"),
                                                             ("All files", "*.*")])
        # Get the absolute coordinates of the canvas without root offsets
        x=self.canvas.winfo_rootx()
        y=self.canvas.winfo_rooty()

        # Get the width and height of the canvas
        x1 = x + self.canvas.winfo_width()
        y1 = y + self.canvas.winfo_height()

        # Grab and crop the region, then save the image
        #ImageGrab.grab().crop((x,y,x1,y1)).save(file_saved)
        image = ImageGrab.grab(bbox=(x, y, x1, y1))
        image.save(file_saved)

        # Show confirmation message
        messagebox.showinfo("Save Successful", f"Canvas saved as {file_saved}")

    #open old cavas
    def open_canvas(self):
        file_open = filedialog.askopenfilename(defaultextension=".jpg",
                                               filetypes=[("JPEG files", "*.jpg"),
                                                          ("PNG files", "*.png"),
                                                          ("All files", "*.*")])
        if file_open:
            # Open the image file
            image = Image.open(file_open)
            # Resize the image to fit the canvas if needed
            image = image.resize((self.canvas.winfo_width(), self.canvas.winfo_height()), Image.LANCZOS)
            self.canvas_image = ImageTk.PhotoImage(image)  # Convert image to Tkinter-compatible format
            # Display the image on the canvas
            self.canvas.create_image(0, 0, image=self.canvas_image, anchor='nw')




if __name__ == '__main__':
    root = tk.Tk()
    window_width = 1400
    window_height = 700
    root.geometry(str(window_width) + 'x' + str(window_height))  # Set initial window size
    root.resizable(True, True)  # Allow window resizing both horizontally and vertically

    app = Application(window_width, window_height, root=root)
    app.mainloop()